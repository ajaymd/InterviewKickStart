Maintain a priority queue or a balanced BST. Keep adding new elements to the BST and if the size of the tree increases more than k, remove the smallest element.

static int[] topK(int[] arr, int k) {
        TreeSet<Integer> tree =new TreeSet<Integer>();
        for(int x:arr){
            tree.add(x);
            if(tree.size()>k){
                tree.pollFirst();
            }
        }
        int ans[]=new int[tree.size()];
        int ptr=0;
        for(int x:tree){
            ans[ptr++]=x;   
        }
        return ans;   
    }