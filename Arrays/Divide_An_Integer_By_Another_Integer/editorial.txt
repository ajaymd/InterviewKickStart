Solution with time complexity O(a / b) and space complexity O(1) can be achieved using addition or subtraction.
We can divide our problem in four parts:
1) a >= 0 and b > 0
2) a < 0 and b > 0
3) a >= 0 and b < 0
4) a < 0 and b < 0

When a >= 0 and b > 0 then we can do something like this:

sum = 0
q = 0
while (sum + b <= a)
	sum += b
	q++
return q
  
Some modification in the above code will also work with other combinations. 

But still we can improve time complexity. 






Lets take a and b such that a % b = 0 so we can write q = a / b. q * b = a. To solve the problem thinking in terms of binary representation will help. 
q * b = q
(q31q30...q0) * b = a (in binary representation) 
(2^31 * q31 + 2^30 * q30 + ... + 2^0 * q0) * b = a 
To find value of each bit we can start from left side. 
First we try to set q31 = 1, if 2^31 * b <= a then we set q31 = 1, but if 2^31 * b > a then we set q31 = 0. 
When we set q31 = 0 then we have to solve 
(2^30 * q30 + ... + 2^0 * q0) * b = a
and when we set q31 = 1 then we have to solve 
(2^30 * q30 + ... + 2^0 * q0) * b = a - 2^31 * b.
For that we can use recursion.






Consider 37 / 3. We keep on left shifting divisor by 1 (multiply by 2) till it does not exceed 37, here so it will be 3 -> 6 -> 12 -> 24. Now we can write our division 37 / 3 = (37 / (3 * 8)) * 8 + (37 - (3 * 8)) / 3. Now first part is (37 / 24) * 8 = 1 * 8 = 1 * 2^(number of shifts). Second part is 13 / 3 and this problem is smaller version of the same problem we are trying to solve, so we use recursion.






Approach we have used is called divide and conqure. 

Time complexity of the function is O(log(a) ^ 2) because of shifting and recursive function calls. 

Auxiliary space and space complexity of solution provided by us is O(log(a)) due to recursive function call. For readability purpose we have used recursive implementation. But we can use iterative implementation to bring down space complexity to O(1). 

If you are using C then direct copy pasting the code provided by us (which is in C++) will not work. In C abs(x) and fabs(x) are different. Use fabs instead of abs. 









