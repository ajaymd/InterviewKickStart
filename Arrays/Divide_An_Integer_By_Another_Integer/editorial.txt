Important thing to note is that int / int does not gaurantee that answer will always be int! Try test case a = -2147483648 and b = -1, answer will be 2147483648 that can not be stored in int. So use appropriate data types. We need to use long long int.  

Lets take a and b such that a % b = 0 so we can write q = a / b. q * b = a. To solve the problem thinking in terms of binary representation will help. 
q * b = q
(q31q30...q0) * b = a (in binary representation) 
(2^31 * q31 + 2^30 * q30 + ... + 2^0 * q0) * b = a 
To find value of each bit we can start from left side. 
First we try to set q31 = 1, if 2^31 * a <= a then we set q31 = 1, but if 2^31 * b > a then we set q31 = 0. 
When we set q31 = 0 then we have to solve 
(2^30 * q30 + ... + 2^0 * q0) * b = a
and when we set q31 = 1 then we have to solve 
(2^30 * q30 + ... + 2^0 * q0) * b = a - 2^31 * b.
For that we can use recursion.

Consider 37 / 3. We keep on left shifting divisor by 1 (multiply by 2) till it does not exceed 37, here so it will be 3 -> 6 -> 12 -> 24. Now we can write our division 37 / 3 = (37 / (3 * 8)) * 8 + (37 - (3 * 8)) / 3. Now first part is (37 / 24) * 8 = 1 * 8 = 1 * 2^(number of shifts). Second part is 13 / 3 and this problem is smaller version of the same problem we are trying to solve, so we use recursion.

Approach we have used is called divide and conqure. 

Time complexity of the function is O(log(a) ^ 2) because of shifting and recursive function calls. 

Auxiliary space and space complexity of solution provided by us is O(log(a)) due to recursive function call. For readability purpose we have used recursive implementation. But we can use iterative implementation to bring down space complexity to O(1). 

If you are using C then direct copy pasting the code provided by us will not work. In C abs(x) and fabs(x) are different. Use fabs instead of abs. 