// Start of BODY
/**
 * TestStruct members::
 *  testcase_id                   [size_t] ID of the test-case
 *  testcase_input_path           [string] File path to test-case input
 *  testcase_output_path          [string] File path to test-case output generated by the problem solver
 *  testcase_expected_output_path [string] File path to test-case expected output to be matched with
 *  metadata_file_paths           [vector<string>] File paths to Question metadata (Extra files usually used for defining traning sets)
 *  submission_code_path          [string] File path to submission source code
 *  testcase_result               [bool] Set to true if test-case output matches test-case expected output. Matching is done line by line
 *  testcase_signal               [size_t] Exit code of the test-case process
 *  testcase_time                 [float] Time taken by the test-case process in seconds
 *  testcase_memory               [size_t] Peak memory of the test-case process determined in bytes
 *  data                          [string] <Future use>
 *
 *
 *  ResultStruct::
 *    result      [bool]  Assign test-case result. true determines success. false determines failure
 *    score       [float] Assign test-case score. Normalized between 0 to 1
 *    message     [string] Assign test-case message. This message is visible to the problem solver
**/
#include<unordered_set>

unordered_set<string> my_brackets;

void find_brackets(int opening, int closing, int n, string s)
{
	if (closing == n)
	{
		my_brackets.insert(s);
		return;
	}
	if (opening < n)
	{
		find_brackets(opening + 1, closing, n, s + '(');		
	}
	if (opening > closing)
	{
		find_brackets(opening, closing + 1, n, s + ')');		
	}
}

void run_custom_checker(const TestStruct t_obj,
                        ResultStruct &r_obj) {
    //Don't print anything to STDOUT in this function
    //Enter your custom checker scoring logic here
    r_obj.result = true;
    r_obj.score = 1.0f;
    r_obj.message = "Success";
    
    ifstream input_file;                                                // freopen is not working
    input_file.open(t_obj.testcase_input_path.c_str()); 
    
    int n;
    input_file >> n;
    
    find_brackets(0, 0, n, "");                                         // Find all the brackets.
    
    ifstream output_file;                                               // freopen is not working 
    output_file.open(t_obj.testcase_output_path.c_str()); 
    
    string s;
    /* 
    Compare output. Line by line scan the output of user and see if that string matches any of the well 
    formed bracket generated by us or not. If not then return wrong answer. If yes then remove that from
    my_brackets. 
    */
    while (output_file >> s)                                       
    {
        auto it = my_brackets.find(s);
        if (it == my_brackets.end())
        {
            r_obj.result = false;
            r_obj.score = 0.0f;
            r_obj.message = "Wrong answer!";
            return;
        }
        my_brackets.erase(it);
    }
    // If there are some brackets that user did not generate then return wrong answer. 
    if (my_brackets.size())
    {
        r_obj.result = false;
        r_obj.score = 0.0f;
        r_obj.message = "Wrong answer!";
    }
}
// End of BODY