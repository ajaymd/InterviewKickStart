When we are dealing with binary tree, our struture looks like:

struct node
{
	int val;
	node *left_child;
	node *right_child;
};

But when we are given k-ary tree then it is not a good idea to manage each pointer separately. (when k = 500 should we define 500 pointers?) 

When we are dealing with k-ary tree, our node structure should look like:
struct node
{
	int val;
	vector<node*> children;
};






Here we only need to find the height hence what value each node is storing does not matter, only thing that matters is how nodes are connected to each other. So in input also we are just given how nodes are connected to each other.





Height of the tree = Number of edges in longest path from root to any node = Number of nodes in longest path from root to any node - 1.

We can find height of tree using height of its subtrees. 

More specifically,

height(parent) = max(height(children)) + 1 	: when parent is not a leaf node. 
0 						: when parent is a leaf node. 

We can use algorithm similar to dfs to do all these calculations. 






Given that root of the tree will always be 1. We can find the children of 1 by looking at the from array. When from[i] = 1, to[i] will be the child of 1. Now we can use the above formula to solve the problem. Also from each child we will solve the same problem with smaller constraints hence we can use recursive calls! 

But in this method, for each node we will iterate over from array to find the children. Hence time complexity will be O(N^2). 

With some modifications we can improve.

Have a look at the code provided by us. 

Time compleity:
O(N) because this is just a modification of dfs on tree.

Auxiliary space:
O(N) because we will store all the N - 1 edges in some array.

Space complexity:
O(N) because of the input size and other vector we are using in the solution. 





