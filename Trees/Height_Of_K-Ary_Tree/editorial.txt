When we are dealing with binary tree, our struture looks like:

struct node
{
	int val;
	node *left_child;
	node *right_child;
};

But when we are given k-ary tree then it is not a good idea to manage each pointer separately. (when k = 500 should we define 500 pointers?) 

When we are dealing with k-ary tree, our node structure should look like:
struct node
{
	int val;
	vector<node*> children;
};






Here we only need to find the height hence what value each node is storing does not matter, only thing that matters is how nodes are connected to each other. So in input also we are just given how nodes are connected to each other. 





Height of the tree = Number of edges in longest path from root to any node = Number of nodes in longest path from root to any node - 1.

We can find height of tree using height of its subtrees. 

More specifically,

height(parent) = max(height(children)) + 1 	: when parent is not a leaf node. 
0 						: when parent is a leaf node. 

We can use algorithm similar to dfs to do all these calculations. 






First we need to create k-ary tree. For that first we can create N nodes, then we add all edges given as from[i] to to[i]. But here we do not know the address of from[i] node and to[i] node! So while creating N nodes we use one unordered_map<int, node*> to store the addresses of created nodees and then we can easily add edges! 

Now have a look at the code provided by us.

Time complexity of the solution is O(N) because our solution is similar to dfs. (Here we have assumed that addition and lookup on random data in unordered_map is O(1))

Auxiliary space used and space complexity of our programme is O(N) because we have used unordered_map to store N addresses and created the k-ary tree of size N. 







